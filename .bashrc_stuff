## stuff to append to .bashrc

#existing_agent="$(ps -ax | rg ssh-agent | awk '{print $5}' | rg ssh-agent | uniq | head)"
#if [ "$existing_agent" != "ssh-agent" ]; then
#    eval $(ssh-agent) 2&>1
#fi

if command -v watchexec >/dev/null 2>&1; then
    alias we='watchexec'
fi
if command -v exa >/dev/null 2>&1; then
    alias ls='exa'
fi
if command -v docker-compose >/dev/null 2>&1; then
    alias dcomp='docker-compose'
fi
if command -v nvim >/dev/null 2>&1; then
    alias vim='nvim'
fi


alias l='ls'
# make destructive things interactive
alias ll='ls -l'
alias rm='rm -i'
alias mv='mv -i'
alias cp='cp -i'

# work git
#WORK_GIT_KEY='secretkeyname'
#alias workgit="GIT_SSH_COMMAND='ssh -i ~/.ssh/$WORK_GIT_KEY' git"


set -o vi
export VISUAL=vim
export EDITOR="$VISUAL"
export TERM=xterm-256color

# postgres
# mac only
#PATH=$PATH:/Applications/Postgres.app/Contents/Versions/9.6/bin

# For node/npm, assumes node binaries have been unpacked into ~/bin/node
export PATH=$PATH:~/bin/node/bin
export PATH=$PATH:~/.node_modules/bin

# For rustup, to access any binaries install via `cargo install`
export PATH="$HOME/.cargo/bin:$PATH"

# local bins
export PATH=~/bin:$PATH
export PATH=~/.local/bin:$PATH

# graalvm
export PATH=~/bin/graalvm/Contents/Home/bin:$PATH

# For rust-racer, if rust source is managed by rustup
#  `rustup component add rust-src`
export RUST_SRC_PATH="$(rustc --print sysroot)/lib/rustlib/src/rust/library"
# `rustup toolchain add nightly && cargo +nightly install racer`
export RACER_PATH="$(which racer)"

# pyenv shim support
#eval "$(pyenv init -)"

# make gpg work on mac
export GPG_TTY=$(tty)

# mac, bash-on
export BASH_SILENCE_DEPRECATION_WARNING=1

# For python/jedi ycm -- set the default location for the jedi env
# mac
#export PYTHON_JEDI_PATH="/Users/james/bin/envs/jedi/bin/python"
# linux
#export PYTHON_JEDI_PATH="/home/james/bin/envs/jedi/bin/python"

# For syntastic python -- set the default location for the flake8 env
# mac
#export PYTHON_FLAKE8_PATH="/Users/james/bin/envs/flake8/bin/flake8"
# linux
#export PYTHON_FLAKE8_PATH="/home/james/bin/envs/flake8/bin/flake8"

# FZF use ripgrep & ctrl-p to open in vim from the shell
export FZF_DEFAULT_COMMAND='rg --files --hidden --follow --glob "!.git/objects"'
export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
if command -v bat >/dev/null 2>&1; then
    bind -x '"\C-p": vim $(fzf --preview '"'bat --color \"always\" {}'"');'
else
    bind -x '"\C-p": vim $(fzf);'
fi

# For Go...
export GOPATH=$HOME/dev/go # default go working dir
export GOROOT=$GOPATH/dev   # install location
export PATH=$PATH:$GOROOT/bin   # ^^
export PATH=$PATH:$GOPATH/bin   # ^^

# upaste
export UPASTE_PASTEROOT=https://paste.kominick.com/new
export UPASTE_READROOT=https://paste.kominick.com
# and helpers
function __open_upaste_from_output {
    awk '{ print $6 }' | head -n 1 | xargs open
}
function pup {
    if [ -z "$1" ]; then
        upaste --raw | __open_upaste_from_output
    else
        upaste --raw --file $1 | __open_upaste_from_output
    fi
}
function pdp {
    upaste --pull $(echo "$1" | tr "/" "\n" | tail -n 1)
}

br() {
    n="10"
    if [ ! -z "$1" ]; then
        n="$1"
    fi

    if [ "$n" -lt "0" ]; then
        # br -1 go to the first line (numbered -1),
        # br -2 go to the second line..
        n="$(( $n * -1 ))"
        git branch --sort=-committerdate \
            | head -n "$n" \
            | tail -n 1 \
            | xargs git checkout
        br
    else
        # list lines with their number
        git branch --sort=-committerdate \
            | head -n "$n" \
            | nl -w 4 -s " => " -i -1 -v -1
    fi
}

gitstats () {
    since="01 Jan 2020"
    if [ ! -z "$1" ]; then
        since="$1"
    fi
    git shortlog -sne --since="$since"
}

# For boost
#export BOOST_ROOT="/home/james/.installs/boost_1_65_0"

# Put VMs on an external drive
#export VAGRANT_HOME=/media/james/sdstore/vagrant_home

#~ If for some reason you need to add repl readline support
# export PYTHONSTARTUP=$HOME/.pythonstartup.py

#~ ssh login notifications
# ~/.installs/pushlogin/ssh_login.py

#~ Git things:
#~ See https://github.com/git/git/tree/master/contrib/completion
# function __init_git_stuff {
#     # branch prompt
#     source ~/bin/git-prompt.sh
#     # branch completion -- may error out
#     source ~/bin/git-completions.bash
# }

# git-completions may error out
#__init_git_stuff

#~ If we're in a plexed shell, set the mltplxr's session id
#plexed_id=""
#if [ "$STY" ]; then
#    IFS=. ID=(${STY})
#    plexed_id='|s.'${ID[0]}
#fi
#if [ "$TMUX" ]; then
#    plexed_id=$plexed_id'|t.'$(tmux display-message -p "#S")
#fi
#

#~ grab the current kubernetes context
# function __kube_ps1 {
#     kinfo=""
#     if command -v kubectx >/dev/null 2>&1; then
#         kinfo="$(kubectx -c)"
#     fi
#     if command -v kubens >/dev/null 2>&1; then
#         kinfo="${kinfo}.$(kubens -c)"
#     fi
#     if [ "$kinfo" ]; then
#         kinfo="|k.${kinfo}"
#     fi
#     echo $kinfo
# }


# export PS1="\[\e[1;32m\]${debian_chroot:+($debian_chroot)}\u@\h\[\e[93m\]${plexed_id}\[\e[1;32m\]\[\e[90m\]\$(__kube_ps1)\[\e[1;32m\]:\[\e[1;34m\]\w\[\e[32m\]\$(__git_ps1)\[\e[35m\]\$\[\e[0m\] "


#~ Pretty red root prompt
# PS1='\[\e[1;91m\]${debian_chroot:+($debian_chroot)}\u@\h:\[\e[1;34m\]\w\[\e[35m\]\$\[\e[0m\] '

# building static rust binaries
# docker pull clux/muslrust
# docker run -v $PWD:/volume -w /volume -t clux/muslrust cargo build
#musl-build() {
#  docker run \
#    -v cargo-cache:/root/.cargo \
#    -v "$PWD:/volume" -w /volume \
#    --rm -it clux/muslrust cargo build --release
#}

# auto-env mac
#source $(brew --prefix autoenv)/activate.sh

# or a simpler version
# cd () {
#     builtin cd $1
#     if [ -f .env ]; then
#         read -p "Source .env? [Y/n]" yn
#         case $yn in
#             "" ) echo "sourcing .env"; source .env;;
#             [Yy] ) echo "sourcing .env"; source .env;;
#             * ) echo "ignoring";;
#         esac
#     fi
# }

## misc mac fixes
#export PATH=$PATH:$(brew --prefix sqlite)/bin
#export PATH=$PATH:/usr/local/mysql/bin
## fix openssl/readline linking issues for python
#export LDFLAGS='-L/usr/local/lib -L/usr/local/opt/openssl/lib -L/usr/local/opt/readline/lib'

# kube aliases
#alias wk="watch -n1 kubectl get pods"
#alias k="kubectl"
#alias mfa="~/.install/aws-mfa/bin/aws-mfa"
#alias kc="kubectx"
#alias unprod="kubectx non-prod"
#alias prod="kubectx prod; kubens core-services"
#alias dev="kubectx non-prod; kubens core-services-dev"
#alias staging="kubectx non-prod; kubens core-services-staging"
#alias providers-prod="kubectx prod; kubens providers"
#alias providers-staging="kubectx non-prod; kubens providers-staging"
#alias providers-dev="kubectx non-prod; kubens providers-dev"
#alias mk="kubectx minikube"
#alias kom="kubectx do-nyc1-kom; kubens default"
#alias kom-refresh-cert="doctl kubernetes cluster kubeconfig save kom"

#function kexec {
#    if [ -z "$1" ]; then
#        echo "please specify a pod name..."
#        k get pods
#        return 1
#    fi
#
#    if [ -z "$2" ]; then
#        cmd=/bin/bash
#        echo "defaulting to cmd=$cmd"
#    else
#        cmd="$2"
#    fi
#    pod=$(k get pods | rg $1 | awk '{print $1}')
#    k exec -it $pod $cmd
#}
#
#function kpf {
#    if [ -z "$1" ]; then
#        echo "please specify a pod name..."
#        k get pods
#        return 1
#    fi
#
#    if [ -z "$2" ]; then
#        pf="4000:80"
#        echo "defaulting to ports=$pf"
#    else
#        pf="$2"
#    fi
#    pod=$(k get pods | rg $1 | awk '{print $1}')
#    k port-forward $pod $pf
#}
#
#function kdesc {
#    if [ -z "$1" ]; then
#        echo "please specify a pod name (or [resource [name]])..."
#        k get pods
#        return 1
#    fi
#
#    if [ -z "$2" ]; then
#        podname="$1"
#        resource="pod"
#        echo "defaulting to resource=$resource"
#    else
#        resource="$1"
#        podname="$2"
#    fi
#    pod=$(k get pods | rg $podname | awk '{print $1}')
#    k describe $resource $pod
#}
#
#function klogs {
#    if [ -z "$1" ]; then
#        echo "please specify a pod name..."
#        k get pods
#        return 1
#    fi
#
#    pod=$(k get pods | rg $1 | awk '{print $1}')
#    k logs -f $pod
#}
#function kgrep {
#    if [[ -z "$1" || -z "$2" ]]; then
#        echo "kgrep pod-pattern grep-pattern [context container]"
#        return 1
#    fi
#    if [[ -z "$3" ]]; then
#        context="1"
#    else
#        context="$3"
#    fi
#    if [[ -z "$4" ]]; then
#        container=""
#    else
#        container="-c $4"
#    fi
#    klog="kubectl logs {} $container"
#    k get pods | rg "$1" | rg Running | awk '{print $1}' | xargs -I {} sh -c "$klog" | rg -C $context -i -e "$2"
#}
#
#function kstat {
#    if [ -z "$1" ]; then
#        echo "please specify a deploy name..."
#        k get deploy
#        return 1
#    fi
#    dep_data=$(k get deploy $1 -o json)
#    echo "images: "
#    echo $dep_data | jq ".spec.template.spec.containers | .[] | .name, .image"
#    echo "updated and ready replicas:"
#    echo $dep_data | jq ".status | .updatedReplicas, .readyReplicas"
#}
