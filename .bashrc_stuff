## stuff to append to .bashrc

if command -v watchexec >/dev/null 2>&1; then
    alias we='watchexec'
fi
if command -v exa >/dev/null 2>&1; then
    alias ls='exa'
fi
if command -v docker-compose >/dev/null 2>&1; then
    alias dcomp='docker-compose'
fi
if command -v nvim >/dev/null 2>&1; then
    alias vim='nvim'
fi


alias l='ls'
# make destructive things interactive
alias ll='ls -l'
alias rm='rm -i'
alias mv='mv -i'
alias cp='cp -i'

# work git
#WORK_GIT_KEY='secretkeyname'
#alias workgit="GIT_SSH_COMMAND='ssh -i ~/.ssh/$WORK_GIT_KEY' git"


set -o vi
export VISUAL=vim
export EDITOR="$VISUAL"
export TERM=xterm-256color

# postgres
# mac only
#PATH=$PATH:/Applications/Postgres.app/Contents/Versions/9.6/bin

# For node/npm, assumes node binaries have been unpacked into ~/bin/node
export PATH=$PATH:~/bin/node/bin
export PATH=$PATH:~/.node_modules/bin

# For rustup, to access any binaries install via `cargo install`
export PATH="$HOME/.cargo/bin:$PATH"

# local bins
export PATH=~/bin:$PATH
export PATH=~/.local/bin:$PATH

# graalvm
export PATH=~/bin/graalvm/Contents/Home/bin:$PATH

# For rust-racer, if rust source is managed by rustup
#  `rustup component add rust-src`
export RUST_SRC_PATH="$(rustc --print sysroot)/lib/rustlib/src/rust/src"
# `rustup toolchain add nightly && cargo +nightly install racer`
export RACER_PATH="$(which racer)"

# pyenv shim support
#eval "$(pyenv init -)"

# make gpg work on mac
export GPG_TTY=$(tty)

# mac, bash-on
export BASH_SILENCE_DEPRECATION_WARNING=1

# For python/jedi ycm -- set the default location for the jedi env
# mac
#export PYTHON_JEDI_PATH="/Users/james/bin/envs/jedi/bin/python"
# linux
#export PYTHON_JEDI_PATH="/home/james/bin/envs/jedi/bin/python"

# For syntastic python -- set the default location for the flake8 env
# mac
#export PYTHON_FLAKE8_PATH="/Users/james/bin/envs/flake8/bin/flake8"
# linux
#export PYTHON_FLAKE8_PATH="/home/james/bin/envs/flake8/bin/flake8"

# FZF use ripgrep & ctrl-p to open in vim from the shell
export FZF_DEFAULT_COMMAND='rg --files --hidden --follow --glob "!.git/objects"'
export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
if command -v bat >/dev/null 2>&1; then
    bind -x '"\C-p": vim $(fzf --preview '"'bat --color \"always\" {}'"');'
else
    bind -x '"\C-p": vim $(fzf);'
fi

# For Go...
export GOPATH=$HOME/dev/go # default go working dir
export GOROOT=$GOPATH/dev   # install location
export PATH=$PATH:$GOROOT/bin   # ^^
export PATH=$PATH:$GOPATH/bin   # ^^

# upaste
export UPASTE_PASTEROOT=https://paste.kominick.com/new
export UPASTE_READROOT=https://paste.kominick.com
# and helpers
function __open_upaste_from_output {
    awk '{ print $6 }' | head -n 1 | xargs open
}
function pup {
    if [ -z "$1" ]; then
        upaste --raw | __open_upaste_from_output
    else
        upaste --raw --file $1 | __open_upaste_from_output
    fi
}
function pdp {
    upaste --pull $(echo "$1" | tr "/" "\n" | tail -n 1)
}

# For boost
#export BOOST_ROOT="/home/james/.installs/boost_1_65_0"

# Put VMs on an external drive
#export VAGRANT_HOME=/media/james/sdstore/vagrant_home

#~ If for some reason you need to add repl readline support
# export PYTHONSTARTUP=$HOME/.pythonstartup.py

#~ ssh login notifications
# ~/.installs/pushlogin/ssh_login.py

#~ Git things:
#~ See https://github.com/git/git/tree/master/contrib/completion
# function __init_git_stuff {
#     # branch prompt
#     source ~/bin/git-prompt.sh
#     # branch completion -- may error out
#     source ~/bin/git-completions.bash
# }

# git-completions may error out
#__init_git_stuff

#~ If we're in a plexed shell, set the mltplxr's session id
#plexed_id=""
#if [ "$STY" ]; then
#    IFS=. ID=(${STY})
#    plexed_id='|s.'${ID[0]}
#fi
#if [ "$TMUX" ]; then
#    plexed_id=$plexed_id'|t.'$(tmux display-message -p "#S")
#fi
#

#PS1='\[\e[1;32m\]${debian_chroot:+($debian_chroot)}\u@\h\[\e[93m\]${plexed_id}\[\e[1;32m\]:\[\e[1;34m\]\w\[\e[32m\]$(__git_ps1)\[\e[35m\]\$\[\e[0m\] '

#~ Pretty red root prompt
# PS1='\[\e[1;91m\]${debian_chroot:+($debian_chroot)}\u@\h:\[\e[1;34m\]\w\[\e[35m\]\$\[\e[0m\] '

# building static rust binaries
# docker pull clux/muslrust
# docker run -v $PWD:/volume -w /volume -t clux/muslrust cargo build
#musl-build() {
#  docker run \
#    -v cargo-cache:/root/.cargo \
#    -v "$PWD:/volume" -w /volume \
#    --rm -it clux/muslrust cargo build --release
#}

# auto-env mac
#source $(brew --prefix autoenv)/activate.sh

# misc mac fixes
#export PATH=$PATH:$(brew --prefix sqlite)/bin
#export PATH=$PATH:/usr/local/mysql/bin

# or a simpler version
# cd () {
#     builtin cd $1
#     if [ -f .env ]; then
#         read -p "Source .env? [Y/n]" yn
#         case $yn in
#             "" ) echo "sourcing .env"; source .env;;
#             [Yy] ) echo "sourcing .env"; source .env;;
#             * ) echo "ignoring";;
#         esac
#     fi
# }

# kube aliases
#alias wk="watch -n1 kubectl get pods"
#alias k="kubectl"
#alias mfa="~/.install/aws-mfa/bin/aws-mfa"
#alias kc="kubectx"
#alias unprod="kubectx non-prod"
#alias prod="kubectx prod; kubens core-services"
#alias dev="kubectx non-prod; kubens core-services-dev"
#alias staging="kubectx non-prod; kubens core-services-staging"
#alias providers-prod="kubectx prod; kubens providers"
#alias providers-staging="kubectx non-prod; kubens providers-staging"
#alias providers-dev="kubectx non-prod; kubens providers-dev"
#alias mk="kubectx minikube"
#alias kom="kubectx do-nyc1-kom; kubens default"
#alias kom-refresh-cert="doctl kubernetes cluster kubeconfig save kom"

#function kexec {
#    if [ -z "$1" ]; then
#        echo "please specify a pod name..."
#        k get pods
#        return 1
#    fi
#
#    if [ -z "$2" ]; then
#        cmd=/bin/bash
#        echo "defaulting to cmd=$cmd"
#    else
#        cmd="$2"
#    fi
#    pod=$(k get pods | rg $1 | awk '{print $1}')
#    k exec -it $pod $cmd
#}
#
#function kpf {
#    if [ -z "$1" ]; then
#        echo "please specify a pod name..."
#        k get pods
#        return 1
#    fi
#
#    if [ -z "$2" ]; then
#        pf="4000:80"
#        echo "defaulting to ports=$pf"
#    else
#        pf="$2"
#    fi
#    pod=$(k get pods | rg $1 | awk '{print $1}')
#    k port-forward $pod $pf
#}
#
#function kdesc {
#    if [ -z "$1" ]; then
#        echo "please specify a pod name (or [resource [name]])..."
#        k get pods
#        return 1
#    fi
#
#    if [ -z "$2" ]; then
#        podname="$1"
#        resource="pod"
#        echo "defaulting to resource=$resource"
#    else
#        resource="$1"
#        podname="$2"
#    fi
#    pod=$(k get pods | rg $podname | awk '{print $1}')
#    k describe $resource $pod
#}
#
#function klogs {
#    if [ -z "$1" ]; then
#        echo "please specify a pod name..."
#        k get pods
#        return 1
#    fi
#
#    pod=$(k get pods | rg $1 | awk '{print $1}')
#    k logs -f $pod
#}
